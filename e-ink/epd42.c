/*
 * epd4in2.c
 *
 *  Created on: 2024 FEB 14
 *      Author: Alex
 */

#include "epd42.h"
#include "main.h"

// By default the display is in portrait mode
#define EPD42_SCREEN_WIDTH 		(400)
#define EPD42_SCREEN_HEIGHT 	(300)

const GPIO_PinState EPD42_BUSY 			= GPIO_PIN_RESET;

static const LUT lut_casual = {
		36, 36, 36, 36, 36,
		{
			0x00, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x0F, 0x0F, 0x00, 0x00, 0x01,
			0x00, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// WW
			0x50, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x90, 0x0F, 0x0F, 0x00, 0x00, 0x01,
			0xA0, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// BW
			0x50, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x90, 0x0F, 0x0F, 0x00, 0x00, 0x01,
			0xA0, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// WB
			0xA0, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x90, 0x0F, 0x0F, 0x00, 0x00, 0x01,
			0x50, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// BB
			0x20, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x90, 0x0F, 0x0F, 0x00, 0x00, 0x01,
			0x10, 0x08, 0x08, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
};

static const LUT lut_partial = {
		44, 42, 42, 42, 42,
		{
			0x00, 0x01, 0x20, 0x01, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,
		// WW
			0x00, 0x01, 0x20, 0x01, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// BW
			0x20, 0x01, 0x20, 0x01, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// WB
			0x10, 0x01, 0x20, 0x01, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// BB
			0x00, 0x01,0x20, 0x01, 0x00, 0x01,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,0x00, 0x00, 0x00, 0x00
		}
};

// Local function forward declarations
static void		EPD75_Init2(void);

bool EPD42_Init(uint8_t layers, bool full) {
	EPD42_InitDspl();
	EPD_SendCommand(PARTIAL_DISPLAY_REFRESH);
	EPD_SendData(0x00);

	return EPD_Init(EPD42_SCREEN_WIDTH, EPD42_SCREEN_HEIGHT, layers, full);
}

void EPD42_InitDspl(void) {
	EPD75_Init2();
	EPD_SetLut(&lut_casual);
}

void EPD42_InitDsplPartial(void) {
	EPD75_Init2();
	EPD_SetLut(&lut_partial);
}

void EPD42_Display(void) {
  	uint32_t data_size = (EPD42_SCREEN_HEIGHT * EPD42_SCREEN_WIDTH) >> 3;
  	uint8_t *data = EPD_GetLayerData(MODE_BLACK);

	EPD_SendCommand(DATA_START_TRANSMISSION_2);
	HAL_Delay(2);
	for (uint16_t i = 0; i < data_size; ++i)
		if (data) EPD_SendData(~data[i]); else EPD_SendData(0xFF);
	HAL_Delay(2);

  	EPD_SendCommand(DISPLAY_REFRESH);
  	EPD_WaitDisplayReady(EPD42_BUSY);
}

void EPD42_DisplayPartial(uint16_t x, uint16_t y, uint16_t w, uint16_t h) {
	// Translate rectangle coordinates to absolute value (is display rotated)
	Rectangle r;
	r.x_upl		= x;
	r.y_upl		= y;
	r.x_lor		= x + w;
	r.y_lor		= y + h;
	if (!EPD_AbsRectangle(&r)) return;						// Invalid coordinates
	x = r.x_upl;
	y = r.y_upl;
	w = r.x_lor - x;										// Columns number (horizontal pixel)
	h = r.y_lor - y;										// Rows number (lines)

	// x should be the multiple of 8
	w += x & 7;												// left border could be moved left, increase area width to cover initial rectangle
	x &= 0xf8;												// Now x is multiple of 8
	w = (w+7) & 0xf8;										// Sometimes add extra byte right to cover initial rectangle
	if (x + w > EPD42_SCREEN_WIDTH) {						// Prevent out of screen
		w = EPD42_SCREEN_WIDTH - x;
	}

	uint8_t  bytes_per_row = (EPD42_SCREEN_WIDTH + 7) >> 3;
	uint16_t first_byte = y * bytes_per_row + (x >> 3);

	uint8_t *layer_data = EPD_GetLayerData(MODE_BLACK);
	if (layer_data) {
		EPD_SetPartialRectangle(x, y, x+w-1, y+h-1);
		EPD_SendCommand(DATA_START_TRANSMISSION_1);
		for (uint16_t i = 0; i < h; ++i) {					// Through rows
			for (uint16_t j = 0; j < w / 8; ++j) {			// Through line
				EPD_SendData(layer_data[first_byte + j]);
			}
			first_byte += bytes_per_row;
		}
		HAL_Delay(2);
		first_byte = y * bytes_per_row + (x >> 3);
		EPD_SendCommand(DATA_START_TRANSMISSION_2);
		for (uint16_t i = 0; i < h; ++i) {					// Through rows
			for (uint16_t j = 0; j < w / 8; ++j) {			// Through line
				EPD_SendData(~layer_data[first_byte + j]);
			}
			first_byte += bytes_per_row;
		}
		HAL_Delay(2);

		EPD_SendCommand(DISPLAY_REFRESH);
		HAL_Delay(10);
		EPD_WaitDisplayReady(EPD42_BUSY);
		EPD_SendCommand(PARTIAL_PTOUT);
	}
}

static void EPD75_Init2(void) {
	EPD_Reset();
	EPD_SendCommand(POWER_SETTING);							// POWER SETTING
	EPD_SendData (0x03);
	EPD_SendData (0x00);
	EPD_SendData (0x2b);
	EPD_SendData (0x2b);

	EPD_SendCommand(BOOSTER_SOFT_START);         			// boost soft start
	EPD_SendData (0x17);									// A
	EPD_SendData (0x17);									// B
	EPD_SendData (0x17);									// C

	EPD_SendCommand(POWER_ON);
	EPD_WaitDisplayReady(EPD42_BUSY);

	EPD_SendCommand(PANEL_SETTING);							// panel setting
	EPD_SendData(0xbf);										// KW-bf   KWR-2F	BWROTP 0f	BWOTP 1f

	EPD_SendCommand(PLL_CONTROL);
	EPD_SendData(0x3c);      								// 3A 100HZ   29 150Hz 39 200HZ	31 171HZ

	EPD_SendCommand(TCON_RESOLUTION);						// resolution setting
	EPD_SendData(EPD42_SCREEN_WIDTH >> 8);
	EPD_SendData(EPD42_SCREEN_WIDTH & 0xff);
	EPD_SendData(EPD42_SCREEN_HEIGHT >> 8);
	EPD_SendData(EPD42_SCREEN_HEIGHT & 0xff);

	EPD_SendCommand(VCM_DC_SETTING_REGISTER);				// vcom_DC setting
	EPD_SendData(0x12);

	EPD_SendCommand(VCOM_AND_DATA_INTERVAL_SETTING);
	EPD_SendData(0x97);
}
